coordinate_frames {
  root_frame = "local";

  
  
  # this is the pelvis/trunk/base link
  body {
    relative_to = "local";
    history = 2000;
    max_frequency = 1000;
    # max_frequency = 333;
    pose_update_channel = "POSE_BODY";
    #update_channel = "HEAD_TO_BODY";  
    initial_transform{
      translation = [ 0, 0, 0 ];
      rpy = [0, 0, 0];
    }
  }

  # this is the pelvis/trunk/base link
  body2 {
    relative_to = "local";
    history = 2000;
    max_frequency = 1000;
    # max_frequency = 333;
    pose_update_channel = "POSE_BoDI";
    #update_channel = "HEAD_TO_BODY";  
    initial_transform{
      translation = [ 0, 0, 0 ];
      rpy = [0, 0, 0];
    }
  }

  head {
    relative_to = "body";
    history = 2000;
    update_channel= "BODY_TO_HEAD";
    initial_transform{
      translation=[  0.19915, 0, 0.59898];  # From bigman_real.urdf (in rviz), Frame "gaze"
      rpy = [0.0 , 0.0 , 0.0 ];
    }
  } 

  imu {
    relative_to = "body";
    history = 2000;
    #update_channel = "BODY_TO_IMU";  
    initial_transform{
      translation = [0.0535, 0.0, 0.0601];  # From bigman_real.urdf "imu_link", for "imu_link2" [0.0135 0.0 0.0601] NOTE: They should be in front (positive x), check that!!
      #rpy = [0,0,0];
      #original corresponding to iit urdf ??
      rpy = [-180,0,0];
    }
  }  

  # this is the right foot
  rfoot {
    relative_to = "local";
    history = 2000;
    # max_frequency = 1000;
    max_frequency = 333;
    pose_update_channel = "POSE_RFOOT";
    #update_channel = "HEAD_TO_BODY";  
    initial_transform{
      translation = [ 0, 0, 0 ];
      rpy = [0, 0, 0];
    }
  }

  # this is the right foot
  lfoot {
    relative_to = "local";
    history = 2000;
    # max_frequency = 1000;
    max_frequency = 333;
    pose_update_channel = "POSE_LFOOT";
    #update_channel = "HEAD_TO_BODY";  
    initial_transform{
      translation = [ 0, 0, 0 ];
      rpy = [0, 0, 0];
    }
  }

  # 4m Hokuyo URG (old style lidar)
#  SCAN {
#    relative_to = "body";
#    history = 2000;
    #update_channel = "BODY_TO_SCAN";
#    initial_transform{
#      translation = [ 0.475, 0.000, -0.143 ];
#      rpy = [180, -0.000, 0.000];
#    }
#  }


  # HDL-32E mid-sized Velodyne
#  VELODYNE {
#    relative_to = "body";
#    history = 2000;
    #update_channel = "BODY_TO_VELODYNE";
#    initial_transform{
#      translation = [ 0.39, 0, 0.269 ];
      # original
      #rpy = [0.0, 0.0, 180.000];
      # mfallon, manual attempt to correct for pitch and roll
#      rpy = [-0.25, -1.4500, 180.000];
#    }
#  }



  
  # Pose as published by Vicon
  # for a short time was VICON_BODY
#  body_vicon {
#    relative_to = "local";
#    history = 2000;
#    update_channel= "VICON_TO_LOCAL";
#    initial_transform{
#      translation=[  0 , 0.0 , 0.0 ];
#      rpy = [0.0 , 0.0 , 0.0 ];
#    }
#  } 
  
  # Transform between marker frame and body
  # (eventually) known fixed transform
  #body_vicon {
  #  relative_to = "vicon";
  #  history = 2000;
  #  update_channel= "VICON_";
  #  initial_transform{
  #    # optimized for new vsk files by A. Valenzuela 21 Mar 2014
  #    translation = [0, 0, 0];
  #    quat = [1, 0, 0, 0];
  #  }
  #} 
  
  #pose_vicon {
  #  relative_to = "local";
  #  history = 2000;
  #  max_frequency = 5;
  #  pose_update_channel= "POSE_VICON";
  #  initial_transform{
  #    translation=[  0 , 0.0 , 0.0 ];
  #    rpy = [0.0 , 0.0 , 0.0 ];
  #  }
  #}


  # An alternative body frame, for comparison with POSE_BODY
  # when developing state estimation
  body_alt {
    # this cannot change - its rigid
    relative_to = "local";
    history = 2000;
    max_frequency = 100;
    pose_update_channel= "POSE_BODY_ALT";
    initial_transform{
      translation=[  0 , 0.0 , 0.0 ];
      rpy = [0.0 , 0.0 , 0.0 ];
    }
  }



  # A convienence frame:
  body_scanmatcher {
    # this cannot change - its rigid
    relative_to = "local";
    history = 2000;
    max_frequency = 100;
    pose_update_channel= "POSE_BODY_SCANMATCHER";
    initial_transform{
      translation=[  0 , 0.0 , 0.0 ];
      rpy = [0.0 , 0.0 , 0.0 ];
    }
  }

  KINECT_RGB {
    relative_to = "body";
    history = 2000;
    max_frequency = 100;
    update_channel = "BODY_TO_KINECT_RGB";
    initial_transform{
      # TEMP: to create and example rotation
      #translation=[  0.0 , 0.5 , 0.0 ];
      #rpy = [0.0, 0.0, 0.0];
      translation=[  0.0 , 0.0 , 0.0 ];
      rpy = [0.0, 0.0, 0.0];
    }
  }  

}


planar_lidars {
  SCAN {
    viewer_color = [ 1.0, 0.0, 0.0 ]; # red
    max_range = 29.0;
    min_range = 0.1;
    frequency = 40;
    laser_type = "HOKUYO_URG";
    coord_frame = "SCAN";
    lcm_channel = "SCAN";
    surround_region = [0, 1000000];
    up_region = [-1,-1];
    down_region = [-1, -1];
    max_range_free_dist = 29.0;
  }

  # required for mav estimator gpf (but not actually used for gpf)
  laser {
    viewer_color = [ 1.0, 0.0, 0.0 ]; # red
    max_range = 29.0;
    min_range = 0.1;
    frequency = 40;
    laser_type = "HOKUYO_UTM";
    coord_frame = "VELODYNE";
    lcm_channel = "VELODYNE";
    surround_region = [0, 1000000];        
    up_region = [-1,-1];
    down_region = [-1, -1];
    max_range_free_dist = 29.0;
  }

}


cameras {

}


state_estimator {
  # when processing from log set
  # false: republish_sensors, republish_cameras, publish_filter_state, gpf_vis, publish_diagnostics
  # true:  enable_at_launch (GPF), republish_incoming_poses (POSE_VICON & BDI)

  # when processing gpf:
  # init from vicon and ins but not pose_meas
  # use VICON_BODY when doing GPF from file
  # gpf_vis = false
  # additionally when running gpf out of process:
  # publish_filter_state=true
  # enable_at_launch = false

  # when running on robot use pose_meas to start from BDI Pose


  pose_channel = "POSE_BODY"; # was POSE_BODY_ALT
  filter_state_channel = "STATE_ESTIMATOR_STATE";
  # the frame at which to draw convariance information in viewer
  pose_render_frame = "body"; # was body_alt

  publish_filter_state = true; #publish alongside pose
  publish_pose = true;
  republish_sensors = true; # if using a log, otherwise make false

  # ins,vicon, pose_meas, viewer
  init_sensors = ["ins", "pose_meas"];

  # For initialization, "viewer" can be used (press the "Initialze humanoid"
  # in the pronto-viewer), or if only "ins", it will use x0, below

  # laser_gpf, ins, rgbd_gpf, fovis, legodo , vicon, pose_meas, laser_gpf_out_of_process
  active_sensors = ["ins", "legodo"]; 

  # was this: 1000000 (1sec) for mav
  utime_history_span =1000000;

  #initial state estimate (relavent states overridden by init sensors)
  sigma0 {
          vb = 0.15; #m/s
          chi_xy = 3.0; #degrees?
          chi_z = 3.0; #degrees?
          Delta_xy = 0.05;#.5; #m
          Delta_z = 0.05;#1;    #m

          gyro_bias = 0; #deg/seg
          accel_bias = 0; #m/s^2 # 0.1 worked during tuning
  }

  ## typical walkman height
  x0 {
    velocity = [0,0,0];
    angular_velocity = [0,0,0];
    position = [0, 0, 1.1174]; # From bigman_real.urdf (in rviz)
    rpy = [0, 0, 0];
  }

  init_message {
    channel = "MAV_STATE_EST_INITIALIZER";
  }

  viewer {
    channel = "MAV_STATE_EST_VIEWER_MEASUREMENT";
    utime_offset = 0; #units 1e-6 seconds
    downsample_factor = 1; # process 1 out of every this many
    roll_forward_on_receive = true;
    publish_head_on_message = true;
  }

  ins {
    channel ="MICROSTRAIN_INS"; # "ATLAS_IMU_BATCH_FILTERED", "MICROSTRAIN_INS";
    utime_offset = 0; #units 1e-6 seconds
    downsample_factor = 1; # process 1 out of every this many. for 333Hz use 1. for 1kHz use 3
    roll_forward_on_receive = true;
    publish_head_on_message = true;

    # microstrain: 0.5 | 0.2 | 0 | 0
    # i always used 0.5 | 0.2 | 0 | 0
    q_gyro = 0.5; #deg/sec
    q_accel = 0.2; #m/s^2
    q_gyro_bias = 0.00; #deg/seg^2 | 0.001 suggested by charlie, but not deemed to be necessary
    q_accel_bias = 0.00; #m/sec^2/sec | 0.001 suggested by charlie and worked well on logs
    frame = "imu";

    #ms
    #timestep_dt = 0.01; # REMEMBER TO CHANGE THIS IF YOU CHANGE THE IMU FREQUENCY or downsample factor
    #bdi
    #timestep_dt = 0.003; # this is 1000/3=333.3R Hz - not 333Hz
    #ms - hyq
    #timestep_dt = 0.006; # REMEMBER TO CHANGE THIS IF YOU CHANGE THE IMU FREQUENCY or downsample factor
    #ms - hyq
    timestep_dt = 0.003; # REMEMBER TO CHANGE THIS IF YOU CHANGE THE IMU FREQUENCY or downsample factor

    num_to_init = 100; # was 100 for microstrain, was 333 for MIT before
# Samples to average to calculate imu bias

# In case the readings are very bad:
    # attempt to detect drastically incorrect initial gyro biases estimates:
    max_initial_gyro_bias = 0.00015; # deg/sec, biases above this will be set to zero

    # apply notch filtering on input: (to atlas imu accel signals)
    atlas_filter = false;
    atlas_filter_freq = 87.0; # correct for after March 2014 work
  }

  gps{
    channel = "UBLOX_GPS_DATA";
    #utime_offset = 273200; #.27 second delay optimized for on 11-05-03-outdoors.01
    utime_offset = 145000; #.145 second delay from fixie-gps-2012-05-12.02
    #utime_offset = 0;
    downsample_factor = 1; # process 1 out of every this many
    roll_forward_on_receive = true;
    publish_head_on_message = false;

    r_xy = 2.0; #m
    r_z = 2.0; #m
  }

  scan_matcher{
    channel = "POSE_VICON";
    utime_offset = 0;
    downsample_factor = 1; # process 1 out of every this many
    roll_forward_on_receive = true;
    publish_head_on_message = false;
    mode = "position_yaw"; # yaw for drc, position 

    r_pxy = 0.01; # position in xy
    r_pz =  0.01; # position in z
    r_vxy = 0.01; # velocity in xy
    r_vz =  0.01; # velocity in z
    r_yaw = 3.0;
  }

  vicon{
    channel = "VICON_TO_LOCAL";
    utime_offset = 0; #units 1e-6 seconds
    downsample_factor = 10; # process 1 out of every this many
    roll_forward_on_receive = true;
    publish_head_on_message = false;

    r_xyz = .01; #m
    r_chi = 3.0; #degrees

    # typically position was used
    mode="position_orient"; # "position_orient"

    # added mfallon, apply this transform to put vicon in body frame
    # as vicon data is assumed to be in the frame defined by Vicon's software
    apply_frame = false;
    frame_from = "body_vicon";
    frame_to = "frontplate_vicon";
  }

  # correct the pose to this value: (to init using Pose BDI)
  pose_meas{
    no_corrections = 100; # apply this number of corrections before going silent
    # channel = "POSE_VICON";
    channel = "POSE_BDI";
    utime_offset = 0; #units 1e-6 seconds
    downsample_factor = 1; # process 1 out of every this many
    roll_forward_on_receive = true;
    publish_head_on_message = false;

    r_xyz = .01; #m
    r_chi = 3.0; #degrees

    mode="position_orient"; # "position" "position_orient"
  }

  laser_gpf_out_of_process {
    utime_offset = 0;
    downsample_factor = 1; # i dont think this is used
    channel = "GPF_MEASUREMENT";
    roll_forward_on_receive = true;
    publish_head_on_message = false;
  }

  laser_gpf {
    utime_offset = 0;
    downsample_factor = 1;  # was 3 but rrg use 1
    channel = "VELODYNE_SUBSAMPLED";
    sensor_mode="pointcloud"; # laser or pointcloud
    roll_forward_on_receive = true;
    publish_head_on_message = false;
    gpf_vis = true;

    # N9:
    #map_name = "/home/mfallon/data/atlas/2014-01-21-vicon-walking/octomap/n9-2014-01-21.bt_blurred_0.5";
    map_name = "octomap.bt_blurred";
    #map_name = "from_lcm"; # this means it will be transmitted at launch
    blur_sigma = 0.3;# 0.3 # added by mfallon. was 0.5 previously in a stand alone process

    # 300 is bare min
    gpf_num_samples = 1000; # 1000 seemed to be noticably better than 500 (which I used alot)

    # according to abe:
    # pos_only - less accurate
    # pos_yaw  - sufficient/typical for fixie
    # pos_chi  - more accurate, use this initially for kmcl
    # mfallon: drc initially used pos_yaw
    gpf_substate = "pos_yaw";

    #laser projection settings
    projection_mode = "motion_interpolate"; # just added, this was motion_project by default, but now using motion_interpolate.
    beam_skip = 16;
    spatial_decimation_min = 0;
    spatial_decimation_max = .5;

    #-----------gpf probability settings-----------
    max_weight_proportion = 0.99; # max sum, for illconditioning. was hard coded as 0.99

    #log-likelihood of an unknown cell in the map
    unknown_loglike = -12.0; #original value used for johnson/parking garage 2012-5-13

    #gpf cov is scaled by sigma_scaling^2 via division of summed log probabilities
    # mfallon, jan 2014: mav used 8.16. I'm going to use something much smaller, mfallon
    # mfallon, mar 2014: i think this should actually be higher if not decimating
    sigma_scaling = 8.16; #8.16 # should be identical to "adams magic scaling factor used for johnson/parking garage 2012-5-13

    # enable the GPF at launch. bit flip with: STATE_EST_LASER_ENABLE/DISABLE. (mfallon april 2014)
    # this should be false for typical operation but true for log testing
    enable_at_launch = false;
  }


  rgbd_gpf {
    utime_offset = 0; #units 1e-6 seconds
    #if running in a separate process the downsampling is applied before processing, and as many as can be processed will be (it will hog cpu)
    # laser 40Hz df: 3 | rgbd 10Hz df: 1
    downsample_factor = 1; # process 1 out of every this many laser readings (come at 40hz)

    #channel = "RGBD_GPF_MEASUREMENT";
    channel = "KINECT_FRAME";
    roll_forward_on_receive = true;
    publish_head_on_message = false;


    # N9:
    map_name = "rgbd_octomap.bt_blurred_0.5";
    gpf_vis = true;

    # 300 is bare min
    gpf_num_samples = 500;

    # according to abe:
    # pos_only - less accurate
    # pos_yaw  - sufficient/typical for fixie
    # pos_chi  - more accurate, use this initially for kmcl
    gpf_substate = "pos_yaw";

    #laser projection settings
    beam_skip = 16;
    spatial_decimation_min = 0;
    spatial_decimation_max = .5;

    #-----------gpf probability settings-----------

    #log-likelihood of an unknown cell in the map
    unknown_loglike = -12.0; #original value used for johnson/parking garage 2012-5-13

    #gpf cov is scaled by sigma_scaling^2 via division of summed log probabilities
    sigma_scaling = 8.16; #3 or  8.16 should be identical to adams magic scaling factor used for johnson/parking garage 2012-5-13
  }


  fovis {

    channel = "KINECT_REL_ODOMETRY";
    mode = "lin_rate"; # linear and rotation rates i.e. velocities

    # velocity variances:
    # 0.50 looks good for very difficult logs
    r_vxyz = 5.0;  # m/s
    # scan matchered used 1.0
    r_vang  = 0.50;  # degrees?

    utime_offset = 0;
    downsample_factor = 1;
    roll_forward_on_receive = true;
    publish_head_on_message = false;
  }

  legodo {

    # channel = "ATLAS_STATE";
    channel = "CORE_ROBOT_STATE";
    # lin_rate           linear velocities
    # lin_rot_rate       linear and rotation rates i.e. velocities
    # pos_and_lin_rate   position and linear velocities
    mode = "lin_rate";    # Recommended
    # mode = "pos_and_lin_rate";

    ##########################
    # [velocity] variances:
    # 0.5 the SE velocity tracks the kinematics - but too closely corrects to spikes
    #     when foot contacts occur the velocities spike. need to classify  (@333Hz)
    # 0.25 was what I used in later development  (@333Hz)
    # 0.1 is too low - the velocity corrections made weren't physically possible.  (@333Hz)
    #     but when paired with lidar,  this worked well (@1kHz)
    # 1.5 paired with a position variance of 0.05m seemed to reduce position jerks in scott's controller transitions
    r_vxyz = 0.50;  # m/s
    r_vang  = 0.50;  # degrees?

    #### Variance for uncertain walking kinematics e.g. breaking and making contact
    # Setting equal to the above values makes this mode disabled
    # 0.75 and 1.00 worked well on batch processing
    r_vxyz_uncertain = 0.50;# 0.75;
    r_vang_uncertain = 0.50;# 1.00;

    ## Variance for Direct [Position] Measurement [NEW]
    # shared between modes
    # 1-2 looks good (with laser, at ~280Hz)
    # 4 twitch is beginning to appear (with laser)
    # 0.05m was useful (without laser), see above
    r_xyz = 2.0;
    ##########################

    utime_offset = 0;
    downsample_factor = 3; # process 1 out of every this many. for 333Hz use 1. for 1kHz use 3
    roll_forward_on_receive = true;
    publish_head_on_message = false;

    # left foot at zero or body/pelvis at POSE_BDI
    initialization_mode = "zero";
    # basic, slaved_once, slaved_always
    integration_mode = "slaved_always";

    # Republish various channels (if reading from a log)
    republish_incoming_poses = false; # republish POSE_VICON and POSE_BDI to the log
    republish_cameras = false;
    publish_diagnostics = false;

    # foot Link in contact with the ground:
    left_standing_link = "l_foot";
    right_standing_link = "r_foot";

    # filter joint positions: "none", "lowpass", "kalman".
    # was always lowpass when running with bdi stepping. scott may need kalman

    # TODO play with the filter for joints
    filter_joint_positions = "none";
    joint_process_noise = 0.01; # proc. and obs. variances for kalman filtering ONLY
    joint_observation_noise = 5E-4;

    # filter kinematics when we think contact occurs
    filter_contact_events = true;

    # Contact Classifier Parameters:
    atlas_weight = 1158.0; # walkman [N]  TODO change var name 
    init_contact_mode = "typical"; # "typical" (for toe off and BDI) or "standing" (for mit control, originally)
    standing_schmitt_level = 0.65; # percentage of atlas_weight, 0.65 for a very long time, but needed higher value for standing

    # "typical" contact mode uses FootContactAlt class in SE
    schmitt_low_threshold = 460; # newtons    Around 40% of total
    schmitt_high_threshold = 520; # newtons   Around 45% of total
    schmitt_low_delay = 100000; # microseconds
    schmitt_high_delay = 100000; # microseconds

	# The following is Atlas specific 
    # Adjust the joint angles using the IHMC torque correction method.
    # adjustment_gain is the spring constant (in radians per Newton-meter of
    # the corresponding joint. The adjustment_gain can be set to inf for
    # joints with no torque deflection. These settings are used both for
    # control and state estimation:
    torque_adjustment = false;
    adjustment_gain = [inf, # back_bkz
                       8000, # back_bky
                       8000, # back_bkx
                       inf, # neck_ay
                       7000, # l_leg_hpz
                       8000, # l_leg_hpx
                       10000, # l_leg_hpy
                       10000, # l_leg_kny
                       10000, # l_leg_aky
                       10000, # l_leg_akx
                       7000, # r_leg_hpz
                       8000, # r_leg_hpx
                       10000, # r_leg_hpy
                       10000, # r_leg_kny
                       10000, # r_leg_aky
                       10000, # r_leg_akx
                       inf, # l_arm_shz
                       inf, # l_arm_shx
                       inf, # l_arm_ely
                       inf, # l_arm_elx
                       inf, # l_arm_uwy
                       inf, # l_arm_mwx
                       inf, # l_arm_lwy
                       inf, # r_arm_shz
                       inf, # r_arm_shx
                       inf, # r_arm_ely
                       inf, # r_arm_elx
                       inf, # r_arm_uwy
                       inf, # r_arm_mwx
                       inf]; # r_arm_lwy
    use_controller_input = false;
  }

  legodo_external {

    # Channel Subscribed to:
    channel = "LEG_ODOMETRY_DELTA";

    # All other parameters are taken from legodo block
  }


  # These setting are only used by the leg odometry driven process: se-leg-odometry
  legodo_driven_process {
    # left foot at zero or body/pelvis at POSE_BDI
    initialization_mode = "bdi";
    # basic, slaved_once, slaved_always
    integration_mode = "slaved_always";
  }
}
